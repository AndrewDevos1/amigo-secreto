Abaixo está um especificação executável e detalhada (design + tarefas) — em português — para que outra IA (ou desenvolvedor) implemente do início ao fim um aplicativo web mínimo (Flask + React) que:

- Recebe uma lista colada no formato de exemplo;
- Parseia e normaliza nomes e telefones;
- Gera uma única fila circular (cada pessoa tira a próxima; último tira o primeiro);
- Mostra uma tabela "quem tirou quem";
- Botões para notificar via WhatsApp (links wa.me) — sem uso de conta WhatsApp Business nem envio server-side (evita dependências externas); opcionalmente descrevo como trocar por API Twilio/WhatsApp se desejar envio programático;
- Sem login, sem persistência (apenas memória / sessão), focado em mínimo funcional.

Incluí também artefatos mínimos de código (exemplos) para acelerar a execução. Siga a ordem: visão geral → regras de parsing → algoritmo de geração (fila circular única) → API (contratos) → frontend (componentes, UX) → preocupações e testes → entrega e deploy.

Resumo arquitetural
- Backend: Flask (Python). Endpoints JSON simples para parse e gerar. Serve os assets do build React em produção.
- Frontend: React (Vite ou CRA minimal) consumindo APIs. UI com 2 telas/estados: 1) Colar lista e validar; 2) Visualizar lista parseada e gerar/mostrar pares + botão WhatsApp.
- Estado: mantido no cliente enquanto a sessão está aberta. Backend apenas processa/parsa (stateless).
- Notificações WhatsApp: via link https://wa.me/{numero}?text={mensagem} (abre chat no WhatsApp do usuário). Número em formato internacional sem "+" (E.164 digits only). Mensagem URL-encoded.

Regras de parsing (detalhadas)
1. Entrada: texto multi-linha. Primeira linha pode ser um título (ex.: "Amigo Secreto - Empresa XYZ") — detecte e guarde como group_name se houver.
2. Cada participante por linha. Separadores esperados: tab (\t), múltiplos espaços ou ' - ' entre nome e telefone. Ex.: "João Silva\t11 91234-5678" ou "Maria Santos 21 98765-4321".
3. Algoritmo para cada linha:
   - Trim.
   - Se linha vazia, ignorar.
   - Detectar header/título: se a linha contém a string "amigo" ou contém '-' e poucas colunas mas sem número, tratar como group_name e não como participante.
   - Para participante: procurar a última sequência de caracteres que contenha dígitos (telefone). Heurística:
     - Use regex que capture (nome_part, phone_part) com:
       - phone_candidate = last group that matches [\d\-\+\s()]{6,}
       - name_candidate = line substring antes do phone_candidate.
     - Se não encontrar, tentar split por tab, ou fallback: split por última ocorrência de espaço duplo.
4. Normalização de telefone:
   - Remover tudo que não seja dígito.
   - Se o número resultante tiver 8-9 dígitos (apenas local), prefixar com 53? NÃO — melhor: ter configuração default_country e default_country_code (por exemplo +55 para Brasil). A heurística:
     - Se número começar com '00' ou '011' ou tiver mais de 11 dígitos, assumir já contém código de país.
     - Se length == 10 or 11 (DDD + number) => prefixar com default_country_code (ex: '55' -> final '55' + digits).
     - Se startswith default_country_code probabilmente já está em E.164.
   - Resultado enviado ao frontend em duas formas: raw_original e normalized_e164_no_plus (ex: "55539981212594") — para gerar wa.me link.
   - Marcar telefone como inválido se digits < 8 ou > 15 após remoções.
5. Nome:
   - Trim e normalização mínima (preservar acentos).
   - Se dois participantes tiverem o mesmo nome, manter e diferenciar via telefone.

Algoritmo de geração de fila circular (única fila ciclo)
- Objetivo: produzir um ciclo 1->2->3->...->n->1 onde a ordem é aleatória e cada participante aparece exatamente uma vez (isto é, uma permutação ciclo único).
- Simples e correto: gerar um array arr com todos os participantes; aplicar Fisher–Yates para embaralhar de forma uniforme; construir pares: for i in 0..n-1 => giver = arr[i], receiver = arr[(i+1) % n].
- Observação: isso sempre produz um único ciclo (a sequência ordenada arr representa exatamente o ciclo (arr[0] arr[1] ... arr[n-1])).
- Garantias: ninguém tira a si mesmo, exceto quando n == 1 (tratar caso especial — erro/avisar).

API Backend (contratos e exemplos)
- Endpoint base: /api
- POST /api/parse
  - Input JSON: { "text": "<texto colado>", "default_country_code": "55" }
  - Output 200: {
      "group_name": "Amigo Secreto - Empresa XYZ" | null,
      "participants": [
        { "id": "<uuid>", "name": "João Silva", "phone_raw":"11 91234-5678", "phone_digits":"5539981212594", "is_phone_valid": true }
      ],
      "errors": [] // mensagens de parsing/linhas ignoradas
    }
- POST /api/generate
  - Input JSON: { "participants": [ { "id": "...", "name":"", "phone_digits":"", ... } ], "group_name": "...", "seed": optional integer or string }
  - Output 200: {
      "pairs": [
        { "giver": {participant object}, "receiver": {participant object} }
      ],
      "warnings": []
    }
- Nota: geração pode ser feita no client; mas centralizar no backend permite testes e logs. Se offline-first preferir, gere no client.

Frontend (telas e componentes)
- Tela única com passos (wizard simples em uma página):
  1. PasteScreen
     - Textarea grande com placeholder com exemplo.
     - Campo opcional: Nome do Grupo (preenchido automaticamente a partir do header se detectado).
     - Campo opcional: Código do país padrão (default "55").
     - Botão "Parsear" (chama POST /api/parse).
     - Mostra preview tabelado dos participantes parseados, com validação (telefone inválido destacado).
  2. GenerateScreen (aparece após parse bem sucedido)
     - Botão "Gerar amigo secreto" — chama POST /api/generate.
     - Mostra AssignmentTable: colunas: #, Giver (nome + telefone), Receiver (nome + telefone), botão WhatsApp (ícone), ícone copiar texto.
     - Botão "Enviar todos por WhatsApp" (aviso: abrirá várias abas/popups e pode ser bloqueado; sugerir usar o botão por linha).
     - Campo mensagem padrão (template) editável: "Olá {giver_name}! Você tirou {receiver_name} no {group_name}! Contato: {receiver_phone_display}".
- Componentes React sugeridos:
  - PasteInput: Textarea + parse button + group_name + default_country_code.
  - ParticipantsTable: lista parseada editável (permitir corrigir nome/telefone inline).
  - AssignmentTable: map de pares + controles WhatsApp.
  - WhatsAppButton: constrói URL com normalized phone e mensagem -> window.open(url, '_blank').
  - NotificationBanner: avisos/popup para informar sobre pop-up blockers.
- UX notes:
  - Permitir edição manual antes de gerar (corrigir parsing).
  - Desabilitar "Enviar todos" se houver telefones inválidos.
  - Mostrar tooltip explicando que os números serão usados no formato internacional.

Mensagens e template WhatsApp
- Template default:
  "Olá {giver_name}! Você tirou {receiver_name} no {group_name}! Contato: {receiver_phone_display}"
- Construção de link:
  - url = "https://wa.me/" + receiver.phone_digits + "?text=" + encodeURIComponent(template_filled)
  - abrir em nova aba: window.open(url, '_blank')
- Observações:
  - O destinatário do link é o "giver" (quem recebe a mensagem) — cuidado ao preencher: o número usado no wa.me deve ser o do giver. Mensagem informar quem ele tirou (receiver). Portanto: wa.me/<giver_number>?text=Olá {giver_name}... você tirou {receiver_name}...
  - Em alguns casos, se se quer que o backend envie, descrever uso de Twilio/WhatsApp Business API (requer conta, verificação). Forneço instruções se desejar.

Validações e casos de borda
- n < 2 -> mensagem "Necessita pelo menos 2 participantes".
- Telefones inválidos -> mostrar em vermelho e bloquear envio.
- Duplicatas de número -> avisar (pode ocorrer).
- Entrada com nomes duplicados -> OK, diferenciar por número.
- Preservar acentos/UTF-8.

Testes unitários e de integração (mínimos)
- Backend:
  - Testar parsing com várias linhas (incluindo header, tabs, espaços).
  - Testar normalização de telefone com diferentes formatos.
  - Testar generate produz ciclos corretos (cada participante aparece exatamente uma vez como giver e receiver).
- Frontend:
  - Testar que componentes exibem corretamente participants; testar construção do link wa.me.

Deploy / execução local mínima
- Backend: requirements.txt (Flask, python-dotenv optional).
- Scripts: flask run (porta 5000).
- Frontend: npm run dev (React Vite) durante desenvolvimento; para produção build -> copiar build para backend static e servir via Flask.
- Docker: opcional Dockerfile para backend e Dockerfile para frontend + docker-compose para orquestra.

Sugestão de estrutura de projeto (mínima)
- backend/
  - app.py
  - parsing.py
  - requirements.txt
- frontend/
  - package.json
  - src/
    - main.jsx
    - App.jsx
    - components/PasteInput.jsx
    - components/ParticipantsTable.jsx
    - components/AssignmentTable.jsx
  - public/index.html
- README.md

Arquivos de exemplo (mínimos para começar)
```python name=backend/app.py
from flask import Flask, request, jsonify, send_from_directory
from parsing import parse_text, generate_pairs
from flask_cors import CORS

app = Flask(__name__, static_folder='../frontend/dist', static_url_path='/')
CORS(app)

@app.route('/api/parse', methods=['POST'])
def api_parse():
    data = request.get_json() or {}
    text = data.get('text', '')
    default_cc = data.get('default_country_code', '55')
    result = parse_text(text, default_cc)
    return jsonify(result)

@app.route('/api/generate', methods=['POST'])
def api_generate():
    data = request.get_json() or {}
    participants = data.get('participants', [])
    group_name = data.get('group_name')
    pairs = generate_pairs(participants)
    return jsonify({"pairs": pairs})

# Serve frontend (production build)
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def serve(path):
    if path != "" and (app.static_folder / path).exists():
        return send_from_directory(app.static_folder, path)
    return send_from_directory(app.static_folder, 'index.html')

if __name__ == '__main__':
    app.run(debug=True)
```

```python name=backend/parsing.py
import re
import uuid
import random

PHONE_RE = re.compile(r'[\d\-\+\s\(\)]{6,}')

def normalize_phone_digits(s, default_cc='55'):
    digits = re.sub(r'\D', '', s or '')
    # heuristic
    if len(digits) >= 11 and digits.startswith(default_cc):
        return digits
    if len(digits) in (10,11):
        return default_cc + digits
    if len(digits) <= 9:
        # local short number: prefix default_cc (may be ambiguous)
        return default_cc + digits
    return digits

def parse_text(text, default_cc='55'):
    lines = text.splitlines()
    participants = []
    group_name = None
    errors = []
    for raw in lines:
        line = raw.strip()
        if not line:
            continue
        # detect header/title
        low = line.lower()
        if ('amigo' in low and 'secreto' in low) or (line.count('-')>=1 and len(line.split())<=6 and not re.search(r'\d', line)):
            group_name = line
            continue
        m = PHONE_RE.search(line)
        if not m:
            errors.append(f"Não foi possível detectar telefone na linha: '{line}'")
            continue
        phone_part = m.group(0)
        name_part = line[:m.start()].strip()
        if not name_part:
            # fallback attempt: split by tab
            parts = re.split(r'\t+', line)
            if len(parts) >= 2:
                name_part = parts[0].strip()
                phone_part = parts[-1].strip()
            else:
                errors.append(f"Nome vazio na linha: '{line}'")
                continue
        phone_digits = normalize_phone_digits(phone_part, default_cc)
        participant = {
            "id": str(uuid.uuid4()),
            "name": name_part,
            "phone_raw": phone_part,
            "phone_digits": phone_digits,
            "is_phone_valid": len(re.sub(r'\D','',phone_digits)) >= 8
        }
        participants.append(participant)
    return {"group_name": group_name, "participants": participants, "errors": errors}

def generate_pairs(participants):
    n = len(participants)
    if n < 2:
        return []
    arr = participants.copy()
    random.shuffle(arr)
    pairs = []
    for i in range(n):
        giver = arr[i]
        receiver = arr[(i+1) % n]
        pairs.append({"giver": giver, "receiver": receiver})
    return pairs
```

```text name=backend/requirements.txt
Flask>=2.0
flask-cors
python-dotenv
```

```json name=frontend/package.json
{
  "name": "amigo-secreto-client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.4.0"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "@vitejs/plugin-react": "^3.0.0"
  }
}
```

```javascript name=frontend/src/App.jsx
import React, {useState} from 'react';
import axios from 'axios';
import PasteInput from './components/PasteInput';
import AssignmentTable from './components/AssignmentTable';

export default function App(){
  const [participants, setParticipants] = useState([]);
  const [groupName, setGroupName] = useState('');
  const [pairs, setPairs] = useState([]);

  async function handleParse(text, defaultCC){
    const resp = await axios.post('/api/parse',{text, default_country_code: defaultCC});
    setParticipants(resp.data.participants || []);
    if(resp.data.group_name) setGroupName(resp.data.group_name);
    if((resp.data.errors||[]).length) alert('Erros: ' + (resp.data.errors||[]).join('\\n'));
  }

  async function handleGenerate(){
    const resp = await axios.post('/api/generate',{participants, group_name: groupName});
    setPairs(resp.data.pairs || []);
  }

  return (
    <div style={{padding:20}}>
      <h1>Amigo Secreto - Minimal</h1>
      <PasteInput onParse={handleParse} defaultGroupName={groupName} onGroupNameChange={setGroupName} />
      <div style={{marginTop:20}}>
        <h2>Participantes ({participants.length})</h2>
        <ul>
          {participants.map(p => <li key={p.id}>{p.name} — {p.phone_raw} — {p.phone_digits}</li>)}
        </ul>
        <button onClick={handleGenerate} disabled={participants.length < 2}>Gerar amigo secreto</button>
      </div>
      <AssignmentTable pairs={pairs} groupName={groupName}/>
    </div>
  );
}
```

```javascript name=frontend/src/components/PasteInput.jsx
import React, {useState} from 'react';

export default function PasteInput({onParse, defaultGroupName, onGroupNameChange}){
  const [text, setText] = useState('');
  const [defaultCC, setDefaultCC] = useState('55');

  return (
    <div>
      <label>Cole a lista (ex.: nome TAB telefone). A primeira linha pode ser o título.</label><br/>
      <textarea value={text} onChange={e=>setText(e.target.value)} rows={10} cols={80} placeholder="Cole aqui..." />
      <div>
        <label>Nome do grupo:</label>
        <input value={defaultGroupName||''} onChange={e=>onGroupNameChange(e.target.value)} />
        <label>Código do país (ex: 55):</label>
        <input value={defaultCC} onChange={e=>setDefaultCC(e.target.value)} style={{width:60}} />
      </div>
      <button onClick={()=>onParse(text, defaultCC)}>Parsear</button>
    </div>
  );
}
```

```javascript name=frontend/src/components/AssignmentTable.jsx
import React from 'react';

function makeWhatsappUrl(to_digits, message){
  const base = 'https://wa.me/';
  return `${base}${to_digits}?text=${encodeURIComponent(message)}`;
}

export default function AssignmentTable({pairs, groupName}){
  if(!pairs || pairs.length===0) return null;
  return (
    <div style={{marginTop:20}}>
      <h2>Resultados</h2>
      <table border="1" cellPadding="6">
        <thead><tr><th>#</th><th>Quem envia</th><th>Telefone</th><th>Recebe</th><th>Ações</th></tr></thead>
        <tbody>
          {pairs.map((p, idx) => {
            const msg = `Olá ${p.giver.name}! Você tirou ${p.receiver.name} no ${groupName || 'Amigo Secreto'}! Contato: ${p.receiver.phone_raw}`;
            const url = makeWhatsappUrl(p.giver.phone_digits, msg);
            return (
              <tr key={idx}>
                <td>{idx+1}</td>
                <td>{p.giver.name}</td>
                <td>{p.giver.phone_raw}</td>
                <td>{p.receiver.name}</td>
                <td>
                  <button onClick={()=>window.open(url, '_blank')}>WhatsApp</button>
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
      <p><i>Atenção: o botão abre o WhatsApp no navegador/dispositivo. O envio fica por conta do usuário no seu WhatsApp.</i></p>
    </div>
  );
}
```

Documento de entrega e passos de implementação
````markdown name=README.md
# Amigo Secreto - Minimal (Flask + React)

Visão: app minimal para gerar "quem tirou quem" a partir de uma lista colada e enviar avisos via WhatsApp.

Passos para rodar localmente (dev):
1. Backend:
   - cd backend
   - python -m venv venv
   - pip install -r requirements.txt
   - export FLASK_APP=app.py
   - flask run
2. Frontend:
   - cd frontend
   - npm install
   - npm run dev
   - No ambiente de produção: npm run build e copiar dist para backend/static para servir via Flask.

Notas de implementação:
- Use CORS em desenvolvimento.
- Testes unitários em parsing.py (pytest).
- Para envio programático por WhatsApp (servidor): integrar Twilio API (requer conta, credenciais e configuração adicional). A alternativa segura para mínimo é usar links wa.me.
````

Recomendações segurança & privacidade
- Evite logs com números de telefone em ambientes públicos.
- Se adicionar persistência (DB), proteger endpoints.
- Avisar usuários que usarão WhatsApp via browser para envio — consentimento.

Opções futuras / melhorias
- Envio automático via WhatsApp Business API (Twilio) com filas e retries.
- Persistência para reusar sorteios.
- Versão com autenticação por organização.
- Enfileiramento (RabbitMQ) para envio assíncrono se optar por envio server-side.
- Export CSV / impressão.

Checklist para a IA/developer que vai executar
1. Implementar parsing.py com testes unitários cobrindo os formatos do exemplo.
2. Implementar endpoints /api/parse e /api/generate conforme contrato.
3. Implementar UI React com componentes indicados; validar comunicação com o backend.
4. Testar manualmente com o texto de exemplo do usuário.
5. Garantir que o botão WhatsApp abre o chat do GIVER com mensagem corretamente preenchida (lembrar: wa.me/<GIVER_PHONE>).
6. Adicionar mensagem de aviso sobre popups/abertura de várias abas.
7. Documentar como construir e rodar (README).

Comentários específicos sobre os dados de exemplo fornecidos
- Os números no exemplo parecem já ter um DDD ("53 ...") e não mostram claramente o código do país. Configurar default_country_code = "55" (Brasil) geralmente funciona: transforma "11 91234-5678" em "55539981212594" para wa.me.

Se quiser, eu gero:
- Um pull request com todo o código inicial (backend + frontend skeleton) pronto para rodar, ou
- Código adicional para envio via Twilio/WhatsApp Business (incluindo filas/retries), ou
- Testes unitários completos para parsing e geração.

Qual das opções você prefere que eu faça agora? (gerar PR com código inicial / só documentação / implementar envio Twilio)