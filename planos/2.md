A seguir estão os diagramas conceituais e as especificações formais (texto + diagramas ASCII) para os dois artefatos que você pediu: Diagrama de Fluxo de Dados (DFD) — Contexto + Level 1 — e Diagrama de Transição de Estados (estado da aplicação / sessão) cobrindo o fluxo do início ao fim. Incluo também o dicionário de dados e uma máquina de estados adicional para a fila de notificações (envio via WhatsApp). Tudo em português e com detalhes suficientes para implementação.

1) DFD — Contexto (DFD Nível 0)
Descrição: visão de alto nível do sistema como um único processo com entradas/saídas externas.

External Entities:
- Usuário (browser)
- WhatsApp (cliente/web) — entidade externa representando o app/serviço do WhatsApp (usado via links wa.me)
- (Opcional) Serviço de Mensagens (ex.: Twilio WhatsApp API) — externo se for adotar envio server-side

Sistema:
- Amigo Secreto App (Flask backend + React frontend)

Data Stores:
- Sessão em memória (SessionStore) — armazenamento temporário no servidor ou no cliente (browser state)
- (Opcional) Persistência (DB) — se escolher salvar sorteios

Fluxos principais:
- Usuário -> Amigo Secreto App: texto colado (lista)
- Amigo Secreto App -> Usuário: lista parseada, validações, pares (quem tira quem), links WhatsApp
- Usuário -> WhatsApp: ação (abre link wa.me)
- (Opcional) Amigo Secreto App -> Twilio: requisição API para envio (se implementado)

Diagrama ASCII (Contexto):
[Usuário] --> (Amigo Secreto App) --> [WhatsApp cliente]
                 |
                 v
            [SessionStore / DB]

2) DFD — Nível 1 (processos detalhados)
Processos identificados:
1.0 Receber entrada do usuário
2.0 Parsear & Normalizar
3.0 Validar & Exibir (UI)
4.0 Gerar Permutação Circular (assignments)
5.0 Gerar Links / Notificações
6.0 (Opcional) Enfileirar envio server-side

Data stores:
D1 SessionStore (ou State no cliente)
D2 AuditLog / Logs
D3 (Opcional) DB de sorteios

External entities:
E1 Usuário
E2 WhatsApp (cliente)
E3 Twilio/WhatsApp Business API (opcional)

Fluxos de dados (descrição):
- E1 -> P1.0: text_input (texto colado)
- P1.0 -> P2.0: text_input
- P2.0 -> D1: participants[] (id, name, phone_raw, phone_digits, is_phone_valid)
- P2.0 -> P3.0: participants[] + parse_errors
- P3.0 -> E1: UI_render (preview, edições permitidas)
- E1 -> P3.0: corrections (edições manuais)
- P3.0 -> D1: participants_final[]
- E1 -> P4.0: trigger_generate
- P4.0 -> D1: assignments[] (pairs)
- P5.0 -> E2: wa.me links when user clicks
- P6.0 -> E3: api_send_request (if server-side)
- P6.0 -> D2: send_log (status)

DFD Nível 1 — Diagrama ASCII simplificado:
[Usuário]
   |
   v
(1.0 Receber input) --> (2.0 Parsear & Normalizar) --> [D1 SessionStore]
                                                  |
                                                  v
                                         (3.0 Validar & Exibir) <--- (edições usu.)
                                                  |
                                       (trigger gerar)
                                                  v
                                         (4.0 Gerar Assignments)
                                                  |
                                                  v
                                         (5.0 Gerar Links/Notifs) --> [WhatsApp cliente]
                                                  |
                                       (opcional server-side)
                                                  v
                                         (6.0 Enfileirar/Enviar) --> [Twilio / API externa]

3) Dicionário de dados (Data Dictionary)
- text_input: string multi-linha colada pelo usuário; pode conter header + N linhas participantes.
- Group:
  - group_name: string|null
  - created_at: timestamp (opcional)
- Participant:
  - id: uuid/string
  - name: string
  - phone_raw: string (como foi digitado)
  - phone_digits: string (apenas dígitos, normalizado para E.164 sem '+', ex: "5513999123456")
  - phone_display: string (formatado para exibição, ex: "(13) 99912-3456")
  - is_phone_valid: boolean
- Assignment (pair):
  - giver_id: participant.id
  - receiver_id: participant.id
  - group_id: optional
- MessageTemplate:
  - template_text: string com placeholders {giver_name}, {receiver_name}, {group_name}, {receiver_phone_display}
- ParseError:
  - line_number: int
  - raw_line: string
  - error_code: enum (PHONE_NOT_FOUND, NAME_MISSING, AMBIGUOUS_FORMAT)
  - message: string amigável
- SessionStore:
  - session_id
  - participants[]
  - assignments[]
  - last_action_timestamp

4) Diagrama de Transição de Estados (Máquina de estados da sessão/app)
Vou descrever a máquina de estados da sessão do usuário (aplicação única) que cobre do início ao fim. Cada estado tem eventos, guardas, e ações associadas.

Estados (alto nível):
- IDLE (estado inicial)
- TEXT_PASTED
- PARSING
- PARSED (ou PARSE_FAILED)
- EDITING
- READY_TO_GENERATE
- GENERATING
- GENERATED
- READY_TO_NOTIFY
- NOTIFYING (ou NOTIFYING_QUEUE)
- COMPLETED
- ERROR

Transições e eventos (detalhadas):

1) IDLE
- Evento: paste_text (usuário cola texto)
- Ação: store raw_text
- Vai para: TEXT_PASTED

2) TEXT_PASTED
- Evento: user_click_parse
- Ação: iniciar parse -> PARSING
- Vai para: PARSING

3) PARSING
- Ação: executar parse_text()
- Se: parse_result.participants.length >= 1 e sem erros críticos -> PARSED
- Se: sem participantes detectados -> PARSE_FAILED (ERROR)
- Guarda: se header detectado, set group_name
- Vai para: PARSED ou ERROR

4) PARSED
- Ação: mostrar participants preview na UI; marcar participants com is_phone_valid flag
- Evento: user_edits (edições manuais) -> vai para EDITING
- Evento: user_click_generate -> se participants_valid_count >= 2 -> READY_TO_GENERATE; senão -> ERROR (show message)

5) EDITING
- Ação: aplicar correções locais no participants[]
- Evento: user_save_edits -> volta a PARSED (ou READY_TO_GENERATE se já válidos)
- Evento: user_cancel -> PARSED

6) READY_TO_GENERATE
- Evento: trigger_generate (user_click_generate)
- Ação: chamar gerar permutação (Fisher-Yates + map circular)
- Vai para: GENERATING

7) GENERATING
- Ação: gerar assignments[]
- Se sucesso -> GENERATED
- Se falha (ex: n < 2) -> ERROR
- Vai para: GENERATED ou ERROR

8) GENERATED
- Ação: apresentar tabela de pares
- Evento: user_edit_pairs (opcional swaps manuais) -> EDITING_PAIRS (sub-estado)
- Evento: user_click_notify -> READY_TO_NOTIFY

9) READY_TO_NOTIFY
- Ação: preparar mensagens (aplicar template)
- Evento: user_click_send_individual(giver) -> abrir wa.me link (efeito externo) -> NOTIFYING (partial)
- Evento: user_click_send_all -> NOTIFYING (start queue)
- Vai para: NOTIFYING

10) NOTIFYING (fila de notificações)
- Ações (modo cliente): para cada assignment:
  - gerar wa.me URL para GIVER (usar giver.phone_digits)
  - window.open(url) por item (abrir novas abas)
  - registrar status localmente (SENT_ATTEMPTED)
- Se server-side com Twilio: fazer chamadas HTTP p/ API; registrar success/fail; retries
- Transição: após processar todos -> COMPLETED
- Em caso de bloqueio de popups: informar e permanecer em READY_TO_NOTIFY com warning

11) COMPLETED
- Ação: mostrar resumo (n enviados, n falhas)
- Evento: user_restart -> voltar para IDLE (limpar session)

12) ERROR (estado genérico)
- Ação: mostrar mensagens, permitir correções (voltar para EDITING ou IDLE conforme caso)
- Evento: user_fix_issue -> voltar para PARSED/EDITING

Diagrama ASCII simplificado de estados:
IDLE --(paste_text)--> TEXT_PASTED --(parse)--> PARSING --(ok)--> PARSED --(generate)--> GENERATING --> GENERATED --> READY_TO_NOTIFY --(send_all)--> NOTIFYING --> COMPLETED
Vias alternativas/correção:
PARSED --(edit)--> EDITING --(save)--> PARSED
Any error --> ERROR --(fix)--> EDITING / PARSED

5) Máquina de estados da fila de notificações (detalhada)
Este é importante para lidar com envios em lote e retries quando houver envio server-side (Twilio). Também reverbera para o comportamento cliente (abrir várias abas).

Estados:
- QUEUE_IDLE (nenhuma mensagem pendente)
- QUEUE_POPULATING (recebendo assignments)
- QUEUE_READY
- SENDING_ONE
- SENT
- FAILED (with retry_count)
- COMPLETED

Transições/ações:
- QUEUE_IDLE -> (assignments pushed) -> QUEUE_POPULATING
- QUEUE_POPULATING -> (finalize queue) -> QUEUE_READY
- QUEUE_READY -> (dequeue next) -> SENDING_ONE (action: build message, call wa.me or call API)
- SENDING_ONE -> SENT (on success) -> back to QUEUE_READY or COMPLETED if empty
- SENDING_ONE -> FAILED (on error) -> if retry_count < max_retries -> requeue after backoff -> QUEUE_READY, else log and continue
- COMPLETED -> show summary

Guardas:
- For wa.me client-mode: SENDING_ONE is a "attempt to open link" and success cannot be reliably detected — mark as ATTEMPTED and track as such; handle pop-up blocker detection (if window.open returned null or blocked).

6) Eventos, Actions e Guard Conditions — tabela curta
- Event: paste_text -> Action: save raw_text -> goto TEXT_PASTED
- Event: parse_click -> Action: parse_text(), create participants -> if count >= 2 goto PARSED else ERROR
- Guard: participants_count >= 2 for generation
- Action in GENERATING: shuffle(arr), create pairs where receiver = next element mod n
- Guard: no self-assignment — with shuffle the only possible self-assignment is if n==1; else safe
- Event: send_click_individual -> Action: build wa.me/<giver_digits>?text=... -> window.open(url)
- Event: send_click_all -> Action: for each pair -> build url and window.open (warn about popup blockers)

7) Mapeamento dos estados para componentes do sistema (implementação)
- React:
  - App state corresponds to session_state (IDLE, PARSED, GENERATED, etc.)
  - PasteInput component triggers paste_text event
  - ParticipantsTable handles EDITING state and transitions back to PARSED
  - GenerateButton triggers GENERATING -> call POST /api/generate or local generation
  - AssignmentTable displays GENERATED state and provides notify actions
  - NotificationQueue component manages NOTIFYING state (shows progress)
- Flask:
  - /api/parse -> synchronous function executed during PARSING (returns parsed participants or errors)
  - /api/generate -> optionally run GENERATING (or client can run)
  - /api/send (opcional) -> endpoint para enfileirar envios server-side (triggers QUEUE_POPULATING -> QUEUE_READY -> SENDING_ONE ...)

8) Casos de borda e decisões arquiteturais relacionadas aos estados
- Pop-up blockers: se enviar todos de uma vez no cliente, muitos window.open podem ser bloqueados. Então:
  - Opção A (recomendação mínima): abrir apenas quando usuário clica por linha (mais robusto).
  - Opção B: abrir em sequência com interação do usuário (ex: botão “Abrir próximo”) ou usando server-side (Twilio).
- Perdendo estado (recarregar página): se estado mantido só no cliente, recarregar limpa sessão. Se isso for problema, persistir em SessionStore (server) ou LocalStorage no browser.
- Erros de parsing: exponha detalhadamente por linha (line number e sugestão de correção), permitindo edição inline.
- Segurança: evite persistir números sem consentimento; se persistir, criptografar em DB e restringir acessos.

9) Exemplo de fluxo completo (sequência de eventos do usuário)
1. Usuário entra na página (state = IDLE).
2. Cola o texto da lista no textarea (evento paste_text -> state = TEXT_PASTED).
3. Clica em Parse (evento parse_click -> state = PARSING).
4. Backend parseia e retorna participants (state -> PARSED). UI exibe preview com flags.
5. Usuário corrige 1 telefone inválido (state -> EDITING -> PARSED).
6. Usuário clica Gerar (guard participants_count>=2) -> state = GENERATING.
7. Sistema gera assignments (shuffle + circular) -> state = GENERATED.
8. UI exibe tabela "quem tirou quem". Usuário revisa e clica WhatsApp por linha (cada clique -> window.open para wa.me/<giver>).
9. Usuário decide enviar todos; UI abre aviso sobre pop-ups; caso confirme, inicia NOTIFYING. URL(s) abertos — progresso exibido.
10. Ao final, state = COMPLETED; mostra resumo. Usuário pode reiniciar -> state = IDLE.

10) Notas finais de engenharia (recomendações)
- Logging: registrar parse_errors e eventos relevantes no AuditLog (D2) para diagnóstico.
- Testes: automatizar testes unitários contra parse_text (variações de formato) e testes de propriedade para gerar assignment (cada id aparece exatamente uma vez como giver e receiver).
- Observabilidade: expor métricas simples (n_parses, n_generations, n_sends_attempted, n_sends_failed).
- UX: destacar telefones inválidos e bloquear envio se houver invalidos; sugerir botão “auto-fix” que tenta adicionar country_code quando missing.

Se quiser eu gero:
- Diagrama em formato .png/svg (mermaid ou PlantUML) para incorporar em documentação;
- Um arquivo PlantUML/mermaid com esses diagramas pronto para renderizar;
- Ou um PR com a documentação + diagramas integrados ao repositório.

Qual formato prefere para os diagramas renderizados (PlantUML, Mermaid ou SVG/PNG pronto)?